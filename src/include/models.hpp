
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.15.0

#include <stan/model/model_header.hpp>

namespace model_censored_correlations_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_cdf(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 6;
        if (as_bool((primitive_value(logical_neq(z1,0)) || primitive_value(logical_neq(z2,0))))) {
            {
                fun_scalar_t__ denom;
                (void) denom;  // dummy to suppress unused var warning

                stan::math::initialize(denom, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(denom,DUMMY_VAR__);
                stan::math::assign(denom,(logical_lt(fabs(rho),1.0) ? sqrt(((1 + rho) * (1 - rho))) : stan::math::not_a_number() ));
                fun_scalar_t__ a1;
                (void) a1;  // dummy to suppress unused var warning

                stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a1,DUMMY_VAR__);
                stan::math::assign(a1,(((z2 / z1) - rho) / denom));
                fun_scalar_t__ a2;
                (void) a2;  // dummy to suppress unused var warning

                stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a2,DUMMY_VAR__);
                stan::math::assign(a2,(((z1 / z2) - rho) / denom));
                fun_scalar_t__ product;
                (void) product;  // dummy to suppress unused var warning

                stan::math::initialize(product, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(product,DUMMY_VAR__);
                stan::math::assign(product,(z1 * z2));
                fun_scalar_t__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                stan::math::assign(delta,(primitive_value(logical_lt(product,0)) || primitive_value((primitive_value(logical_eq(product,0)) && primitive_value(logical_lt((z1 + z2),0))))));


                current_statement_begin__ = 12;
                return stan::math::promote_scalar<fun_return_scalar_t__>((((0.5 * ((Phi(z1) + Phi(z2)) - delta)) - owens_t(z1,a1)) - owens_t(z2,a2)));
            }
        }
        current_statement_begin__ = 14;
        return stan::math::promote_scalar<fun_return_scalar_t__>((0.25 + (asin(rho) / (2 * stan::math::pi()))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) const {
        return binormal_cdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_ccdf(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 18;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binormal_cdf(-(z1),-(z2),rho, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_ccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) const {
        return binormal_ccdf(z1, z2, rho, pstream__);
    }
};

class model_censored_correlations : public prob_grad {
private:
    int N;
    vector<double> x;
    vector<double> y;
    vector<int> cens_x;
    vector<int> cens_y;
public:
    model_censored_correlations(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        ctor_body(context__, base_rng, pstream__);
    }

    template <class RNG>
    model_censored_correlations(stan::io::var_context& context__,
        RNG& base_rng__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, base_rng__, pstream__);
    }

    template <class RNG>
    void ctor_body(stan::io::var_context& context__,
                   RNG& base_rng__,
                   std::ostream* pstream__) {
        current_statement_begin__ = -1;

        static const char* function__ = "model_censored_correlations_namespace::model_censored_correlations";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("x", "N", N);
        context__.validate_dims("data initialization", "x", "double", context__.to_vec(N));
        validate_non_negative_index("x", "N", N);
        x = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x");
        pos__ = 0;
        size_t x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_limit_0__; ++i_0__) {
            x[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "double", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_limit_0__; ++i_0__) {
            y[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("cens_x", "N", N);
        context__.validate_dims("data initialization", "cens_x", "int", context__.to_vec(N));
        validate_non_negative_index("cens_x", "N", N);
        cens_x = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_x");
        pos__ = 0;
        size_t cens_x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_x_limit_0__; ++i_0__) {
            cens_x[i_0__] = vals_i__[pos__++];
        }
        validate_non_negative_index("cens_y", "N", N);
        context__.validate_dims("data initialization", "cens_y", "int", context__.to_vec(N));
        validate_non_negative_index("cens_y", "N", N);
        cens_y = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_y");
        pos__ = 0;
        size_t cens_y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_y_limit_0__; ++i_0__) {
            cens_y[i_0__] = vals_i__[pos__++];
        }

        // validate, data variables
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_censored_correlations() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma_x")))
            throw std::runtime_error("variable sigma_x missing");
        vals_r__ = context__.vals_r("sigma_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_x", "double", context__.to_vec());
        // generate_declaration sigma_x
        double sigma_x(0);
        sigma_x = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_x: ") + e.what());
        }

        if (!(context__.contains_r("sigma_y")))
            throw std::runtime_error("variable sigma_y missing");
        vals_r__ = context__.vals_r("sigma_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_y", "double", context__.to_vec());
        // generate_declaration sigma_y
        double sigma_y(0);
        sigma_y = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_y: ") + e.what());
        }

        if (!(context__.contains_r("mu_x")))
            throw std::runtime_error("variable mu_x missing");
        vals_r__ = context__.vals_r("mu_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_x", "double", context__.to_vec());
        // generate_declaration mu_x
        double mu_x(0);
        mu_x = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_x: ") + e.what());
        }

        if (!(context__.contains_r("mu_y")))
            throw std::runtime_error("variable mu_y missing");
        vals_r__ = context__.vals_r("mu_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_y", "double", context__.to_vec());
        // generate_declaration mu_y
        double mu_y(0);
        mu_y = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_y: ") + e.what());
        }

        if (!(context__.contains_r("rho")))
            throw std::runtime_error("variable rho missing");
        vals_r__ = context__.vals_r("rho");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho", "double", context__.to_vec());
        // generate_declaration rho
        double rho(0);
        rho = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ sigma_x;
        (void) sigma_x;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_x = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_x = in__.scalar_lb_constrain(0);

        T__ sigma_y;
        (void) sigma_y;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_y = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_y = in__.scalar_lb_constrain(0);

        T__ mu_x;
        (void) mu_x;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_x = in__.scalar_constrain(lp__);
        else
            mu_x = in__.scalar_constrain();

        T__ mu_y;
        (void) mu_y;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_y = in__.scalar_constrain(lp__);
        else
            mu_y = in__.scalar_constrain();

        T__ rho;
        (void) rho;  // dummy to suppress unused var warning
        if (jacobian__)
            rho = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho = in__.scalar_lub_constrain(-(1),1);


        // transformed parameters
        validate_non_negative_index("mu", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, DUMMY_VAR__);
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, DUMMY_VAR__);
        stan::math::fill(T,DUMMY_VAR__);


        try {
            current_statement_begin__ = 40;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 41;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 42;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 43;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 45;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 46;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        stan::math::check_cov_matrix(function__,"T",T);

        // model body
        try {

            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(mu_x, 0, 1));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(mu_y, 0, 1));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(sigma_x, 1, 1));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(sigma_y, 1, 1));
            current_statement_begin__ = 57;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 58;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 59;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(x,i,"x",1)).add(get_base1(y,i,"y",1)).array()),mu,T));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 62;
                    lp_accum__.add((normal_log(get_base1(x,i,"x",1),mu_x,sigma_x) + normal_cdf_log(get_base1(y,i,"y",1),(mu_y + ((rho * (sigma_y / sigma_x)) * (get_base1(x,i,"x",1) - mu_x))),(sigma_y * sqrt((1 - square(rho)))))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 65;
                    lp_accum__.add((normal_log(get_base1(y,i,"y",1),mu_y,sigma_y) + normal_cdf_log(get_base1(x,i,"x",1),(mu_x + ((rho * (sigma_x / sigma_y)) * (get_base1(y,i,"y",1) - mu_y))),(sigma_x * sqrt((1 - square(rho)))))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 68;
                    lp_accum__.add(log(binormal_cdf(((get_base1(x,i,"x",1) - mu_x) / sigma_x),((get_base1(y,i,"y",1) - mu_y) / sigma_y),rho, pstream__)));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma_x");
        names__.push_back("sigma_y");
        names__.push_back("mu_x");
        names__.push_back("mu_y");
        names__.push_back("rho");
        names__.push_back("mu");
        names__.push_back("T");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_censored_correlations_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double sigma_x = in__.scalar_lb_constrain(0);
        double sigma_y = in__.scalar_lb_constrain(0);
        double mu_x = in__.scalar_constrain();
        double mu_y = in__.scalar_constrain();
        double rho = in__.scalar_lub_constrain(-(1),1);
        vars__.push_back(sigma_x);
        vars__.push_back(sigma_y);
        vars__.push_back(mu_x);
        vars__.push_back(mu_y);
        vars__.push_back(rho);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        validate_non_negative_index("mu", "2", 2);
        vector_d mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        matrix_d T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T,DUMMY_VAR__);


        try {
            current_statement_begin__ = 40;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 41;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 42;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 43;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 45;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 46;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        stan::math::check_cov_matrix(function__,"T",T);

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu[k_0__]);
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T(k_0__, k_1__));
            }
        }

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_censored_correlations";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.15.0

#include <stan/model/model_header.hpp>

namespace model_censored_correlations_interval_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_cdf(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 6;
        if (as_bool((primitive_value(logical_neq(z1,0)) || primitive_value(logical_neq(z2,0))))) {
            {
                fun_scalar_t__ denom;
                (void) denom;  // dummy to suppress unused var warning

                stan::math::initialize(denom, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(denom,DUMMY_VAR__);
                stan::math::assign(denom,(logical_lt(fabs(rho),1.0) ? sqrt(((1 + rho) * (1 - rho))) : stan::math::not_a_number() ));
                fun_scalar_t__ a1;
                (void) a1;  // dummy to suppress unused var warning

                stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a1,DUMMY_VAR__);
                stan::math::assign(a1,(((z2 / z1) - rho) / denom));
                fun_scalar_t__ a2;
                (void) a2;  // dummy to suppress unused var warning

                stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a2,DUMMY_VAR__);
                stan::math::assign(a2,(((z1 / z2) - rho) / denom));
                fun_scalar_t__ product;
                (void) product;  // dummy to suppress unused var warning

                stan::math::initialize(product, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(product,DUMMY_VAR__);
                stan::math::assign(product,(z1 * z2));
                fun_scalar_t__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                stan::math::assign(delta,(primitive_value(logical_lt(product,0)) || primitive_value((primitive_value(logical_eq(product,0)) && primitive_value(logical_lt((z1 + z2),0))))));


                current_statement_begin__ = 12;
                return stan::math::promote_scalar<fun_return_scalar_t__>((((0.5 * ((Phi(z1) + Phi(z2)) - delta)) - owens_t(z1,a1)) - owens_t(z2,a2)));
            }
        }
        current_statement_begin__ = 14;
        return stan::math::promote_scalar<fun_return_scalar_t__>((0.25 + (asin(rho) / (2 * stan::math::pi()))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) const {
        return binormal_cdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_ccdf(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 18;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binormal_cdf(-(z1),-(z2),rho, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_ccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) const {
        return binormal_ccdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
log_sub_exp(const T0__& a,
                const T1__& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 22;
        return stan::math::promote_scalar<fun_return_scalar_t__>((logical_gt(a,b) ? (a + log((1 - exp((b - a))))) : (b + log((exp((a - b)) - 1))) ));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct log_sub_exp_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& a,
                const T1__& b, std::ostream* pstream__) const {
        return log_sub_exp(a, b, pstream__);
    }
};

class model_censored_correlations_interval : public prob_grad {
private:
    int N;
    vector<double> x_lower;
    vector<double> x_upper;
    vector<double> y_lower;
    vector<double> y_upper;
    vector<int> cens_x;
    vector<int> cens_y;
public:
    model_censored_correlations_interval(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        ctor_body(context__, base_rng, pstream__);
    }

    template <class RNG>
    model_censored_correlations_interval(stan::io::var_context& context__,
        RNG& base_rng__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, base_rng__, pstream__);
    }

    template <class RNG>
    void ctor_body(stan::io::var_context& context__,
                   RNG& base_rng__,
                   std::ostream* pstream__) {
        current_statement_begin__ = -1;

        static const char* function__ = "model_censored_correlations_interval_namespace::model_censored_correlations_interval";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("x_lower", "N", N);
        context__.validate_dims("data initialization", "x_lower", "double", context__.to_vec(N));
        validate_non_negative_index("x_lower", "N", N);
        x_lower = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x_lower");
        pos__ = 0;
        size_t x_lower_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_lower_limit_0__; ++i_0__) {
            x_lower[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("x_upper", "N", N);
        context__.validate_dims("data initialization", "x_upper", "double", context__.to_vec(N));
        validate_non_negative_index("x_upper", "N", N);
        x_upper = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x_upper");
        pos__ = 0;
        size_t x_upper_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_upper_limit_0__; ++i_0__) {
            x_upper[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y_lower", "N", N);
        context__.validate_dims("data initialization", "y_lower", "double", context__.to_vec(N));
        validate_non_negative_index("y_lower", "N", N);
        y_lower = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y_lower");
        pos__ = 0;
        size_t y_lower_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_lower_limit_0__; ++i_0__) {
            y_lower[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y_upper", "N", N);
        context__.validate_dims("data initialization", "y_upper", "double", context__.to_vec(N));
        validate_non_negative_index("y_upper", "N", N);
        y_upper = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y_upper");
        pos__ = 0;
        size_t y_upper_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_upper_limit_0__; ++i_0__) {
            y_upper[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("cens_x", "N", N);
        context__.validate_dims("data initialization", "cens_x", "int", context__.to_vec(N));
        validate_non_negative_index("cens_x", "N", N);
        cens_x = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_x");
        pos__ = 0;
        size_t cens_x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_x_limit_0__; ++i_0__) {
            cens_x[i_0__] = vals_i__[pos__++];
        }
        validate_non_negative_index("cens_y", "N", N);
        context__.validate_dims("data initialization", "cens_y", "int", context__.to_vec(N));
        validate_non_negative_index("cens_y", "N", N);
        cens_y = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_y");
        pos__ = 0;
        size_t cens_y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_y_limit_0__; ++i_0__) {
            cens_y[i_0__] = vals_i__[pos__++];
        }

        // validate, data variables
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_censored_correlations_interval() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma_x")))
            throw std::runtime_error("variable sigma_x missing");
        vals_r__ = context__.vals_r("sigma_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_x", "double", context__.to_vec());
        // generate_declaration sigma_x
        double sigma_x(0);
        sigma_x = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_x: ") + e.what());
        }

        if (!(context__.contains_r("sigma_y")))
            throw std::runtime_error("variable sigma_y missing");
        vals_r__ = context__.vals_r("sigma_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_y", "double", context__.to_vec());
        // generate_declaration sigma_y
        double sigma_y(0);
        sigma_y = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_y: ") + e.what());
        }

        if (!(context__.contains_r("mu_x")))
            throw std::runtime_error("variable mu_x missing");
        vals_r__ = context__.vals_r("mu_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_x", "double", context__.to_vec());
        // generate_declaration mu_x
        double mu_x(0);
        mu_x = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_x: ") + e.what());
        }

        if (!(context__.contains_r("mu_y")))
            throw std::runtime_error("variable mu_y missing");
        vals_r__ = context__.vals_r("mu_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_y", "double", context__.to_vec());
        // generate_declaration mu_y
        double mu_y(0);
        mu_y = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_y: ") + e.what());
        }

        if (!(context__.contains_r("rho")))
            throw std::runtime_error("variable rho missing");
        vals_r__ = context__.vals_r("rho");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho", "double", context__.to_vec());
        // generate_declaration rho
        double rho(0);
        rho = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ sigma_x;
        (void) sigma_x;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_x = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_x = in__.scalar_lb_constrain(0);

        T__ sigma_y;
        (void) sigma_y;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_y = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_y = in__.scalar_lb_constrain(0);

        T__ mu_x;
        (void) mu_x;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_x = in__.scalar_constrain(lp__);
        else
            mu_x = in__.scalar_constrain();

        T__ mu_y;
        (void) mu_y;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_y = in__.scalar_constrain(lp__);
        else
            mu_y = in__.scalar_constrain();

        T__ rho;
        (void) rho;  // dummy to suppress unused var warning
        if (jacobian__)
            rho = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho = in__.scalar_lub_constrain(-(1),1);


        // transformed parameters
        validate_non_negative_index("mu", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, DUMMY_VAR__);
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, DUMMY_VAR__);
        stan::math::fill(T,DUMMY_VAR__);
        T__ sigma_x_adj;
        (void) sigma_x_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_x_adj, DUMMY_VAR__);
        stan::math::fill(sigma_x_adj,DUMMY_VAR__);
        T__ sigma_y_adj;
        (void) sigma_y_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_y_adj, DUMMY_VAR__);
        stan::math::fill(sigma_y_adj,DUMMY_VAR__);
        T__ rho_xy_coef;
        (void) rho_xy_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_xy_coef, DUMMY_VAR__);
        stan::math::fill(rho_xy_coef,DUMMY_VAR__);
        T__ rho_yx_coef;
        (void) rho_yx_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_yx_coef, DUMMY_VAR__);
        stan::math::fill(rho_yx_coef,DUMMY_VAR__);


        try {
            current_statement_begin__ = 55;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 56;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 57;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 58;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 60;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 61;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
            current_statement_begin__ = 63;
            stan::math::assign(sigma_x_adj, (sigma_x * sqrt((1 - square(rho)))));
            current_statement_begin__ = 64;
            stan::math::assign(sigma_y_adj, (sigma_y * sqrt((1 - square(rho)))));
            current_statement_begin__ = 66;
            stan::math::assign(rho_xy_coef, (rho * (sigma_x / sigma_y)));
            current_statement_begin__ = 67;
            stan::math::assign(rho_yx_coef, (rho * (sigma_y / sigma_x)));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }
        if (stan::math::is_uninitialized(sigma_x_adj)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sigma_x_adj";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(sigma_y_adj)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sigma_y_adj";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(rho_xy_coef)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: rho_xy_coef";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(rho_yx_coef)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: rho_yx_coef";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        stan::math::check_cov_matrix(function__,"T",T);

        // model body
        try {

            current_statement_begin__ = 71;
            lp_accum__.add(normal_log<propto__>(mu_x, 0, 1));
            current_statement_begin__ = 72;
            lp_accum__.add(normal_log<propto__>(mu_y, 0, 1));
            current_statement_begin__ = 74;
            lp_accum__.add(normal_log<propto__>(sigma_x, 1, 1));
            current_statement_begin__ = 75;
            lp_accum__.add(normal_log<propto__>(sigma_y, 1, 1));
            current_statement_begin__ = 78;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 80;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 81;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(x_lower,i,"x_lower",1)).add(get_base1(y_lower,i,"y_lower",1)).array()),mu,T));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_neq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 86;
                    lp_accum__.add(normal_log(get_base1(x_lower,i,"x_lower",1),mu_x,sigma_x));
                    current_statement_begin__ = 88;
                    if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))) {

                        current_statement_begin__ = 89;
                        lp_accum__.add(normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),1))) {

                        current_statement_begin__ = 92;
                        lp_accum__.add(normal_ccdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),2))) {

                        current_statement_begin__ = 95;
                        lp_accum__.add(log_sub_exp(normal_cdf_log(get_base1(y_upper,i,"y_upper",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj),normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj), pstream__));
                    }
                } else if (as_bool((primitive_value(logical_neq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 104;
                    lp_accum__.add(normal_log(get_base1(y_lower,i,"y_lower",1),mu_y,sigma_y));
                    current_statement_begin__ = 106;
                    if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1)))) {

                        current_statement_begin__ = 107;
                        lp_accum__.add(normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),1))) {

                        current_statement_begin__ = 110;
                        lp_accum__.add(normal_ccdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),2))) {

                        current_statement_begin__ = 113;
                        lp_accum__.add(log_sub_exp(normal_cdf_log(get_base1(x_upper,i,"x_upper",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj),normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj), pstream__));
                    }
                }
                current_statement_begin__ = 121;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 122;
                    lp_accum__.add(log(binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 127;
                    lp_accum__.add(log(binormal_ccdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 131;
                    lp_accum__.add(log(binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),-(rho), pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 136;
                    lp_accum__.add(log(binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),-(rho), pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 140;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 145;
                    lp_accum__.add(log((binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho, pstream__) - binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 149;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 154;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),rho, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),rho, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 158;
                    lp_accum__.add(log((((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho, pstream__)) - binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__)) + binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho, pstream__))));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma_x");
        names__.push_back("sigma_y");
        names__.push_back("mu_x");
        names__.push_back("mu_y");
        names__.push_back("rho");
        names__.push_back("mu");
        names__.push_back("T");
        names__.push_back("sigma_x_adj");
        names__.push_back("sigma_y_adj");
        names__.push_back("rho_xy_coef");
        names__.push_back("rho_yx_coef");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_censored_correlations_interval_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double sigma_x = in__.scalar_lb_constrain(0);
        double sigma_y = in__.scalar_lb_constrain(0);
        double mu_x = in__.scalar_constrain();
        double mu_y = in__.scalar_constrain();
        double rho = in__.scalar_lub_constrain(-(1),1);
        vars__.push_back(sigma_x);
        vars__.push_back(sigma_y);
        vars__.push_back(mu_x);
        vars__.push_back(mu_y);
        vars__.push_back(rho);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        validate_non_negative_index("mu", "2", 2);
        vector_d mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        matrix_d T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T,DUMMY_VAR__);
        double sigma_x_adj(0.0);
        (void) sigma_x_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_x_adj, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_x_adj,DUMMY_VAR__);
        double sigma_y_adj(0.0);
        (void) sigma_y_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_y_adj, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_y_adj,DUMMY_VAR__);
        double rho_xy_coef(0.0);
        (void) rho_xy_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_xy_coef, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rho_xy_coef,DUMMY_VAR__);
        double rho_yx_coef(0.0);
        (void) rho_yx_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_yx_coef, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rho_yx_coef,DUMMY_VAR__);


        try {
            current_statement_begin__ = 55;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 56;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 57;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 58;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 60;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 61;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
            current_statement_begin__ = 63;
            stan::math::assign(sigma_x_adj, (sigma_x * sqrt((1 - square(rho)))));
            current_statement_begin__ = 64;
            stan::math::assign(sigma_y_adj, (sigma_y * sqrt((1 - square(rho)))));
            current_statement_begin__ = 66;
            stan::math::assign(rho_xy_coef, (rho * (sigma_x / sigma_y)));
            current_statement_begin__ = 67;
            stan::math::assign(rho_yx_coef, (rho * (sigma_y / sigma_x)));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        stan::math::check_cov_matrix(function__,"T",T);

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu[k_0__]);
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T(k_0__, k_1__));
            }
        }
        vars__.push_back(sigma_x_adj);
        vars__.push_back(sigma_y_adj);
        vars__.push_back(rho_xy_coef);
        vars__.push_back(rho_yx_coef);

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_censored_correlations_interval";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy_coef";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yx_coef";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy_coef";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yx_coef";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.15.0

#include <stan/model/model_header.hpp>

namespace model_censored_correlations_unkown_l_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_cdf(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 6;
        if (as_bool((primitive_value(logical_neq(z1,0)) || primitive_value(logical_neq(z2,0))))) {
            {
                fun_scalar_t__ denom;
                (void) denom;  // dummy to suppress unused var warning

                stan::math::initialize(denom, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(denom,DUMMY_VAR__);
                stan::math::assign(denom,(logical_lt(fabs(rho),1.0) ? sqrt(((1 + rho) * (1 - rho))) : stan::math::not_a_number() ));
                fun_scalar_t__ a1;
                (void) a1;  // dummy to suppress unused var warning

                stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a1,DUMMY_VAR__);
                stan::math::assign(a1,(((z2 / z1) - rho) / denom));
                fun_scalar_t__ a2;
                (void) a2;  // dummy to suppress unused var warning

                stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a2,DUMMY_VAR__);
                stan::math::assign(a2,(((z1 / z2) - rho) / denom));
                fun_scalar_t__ product;
                (void) product;  // dummy to suppress unused var warning

                stan::math::initialize(product, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(product,DUMMY_VAR__);
                stan::math::assign(product,(z1 * z2));
                fun_scalar_t__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                stan::math::assign(delta,(primitive_value(logical_lt(product,0)) || primitive_value((primitive_value(logical_eq(product,0)) && primitive_value(logical_lt((z1 + z2),0))))));


                current_statement_begin__ = 12;
                return stan::math::promote_scalar<fun_return_scalar_t__>((((0.5 * ((Phi(z1) + Phi(z2)) - delta)) - owens_t(z1,a1)) - owens_t(z2,a2)));
            }
        }
        current_statement_begin__ = 14;
        return stan::math::promote_scalar<fun_return_scalar_t__>((0.25 + (asin(rho) / (2 * stan::math::pi()))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) const {
        return binormal_cdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_ccdf(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 18;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binormal_cdf(-(z1),-(z2),rho, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_ccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) const {
        return binormal_ccdf(z1, z2, rho, pstream__);
    }
};

class model_censored_correlations_unkown_l : public prob_grad {
private:
    int N;
    vector<double> x;
    vector<double> y;
    vector<int> cens_x;
    vector<int> cens_y;
public:
    model_censored_correlations_unkown_l(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        ctor_body(context__, base_rng, pstream__);
    }

    template <class RNG>
    model_censored_correlations_unkown_l(stan::io::var_context& context__,
        RNG& base_rng__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, base_rng__, pstream__);
    }

    template <class RNG>
    void ctor_body(stan::io::var_context& context__,
                   RNG& base_rng__,
                   std::ostream* pstream__) {
        current_statement_begin__ = -1;

        static const char* function__ = "model_censored_correlations_unkown_l_namespace::model_censored_correlations_unkown_l";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("x", "N", N);
        context__.validate_dims("data initialization", "x", "double", context__.to_vec(N));
        validate_non_negative_index("x", "N", N);
        x = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x");
        pos__ = 0;
        size_t x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_limit_0__; ++i_0__) {
            x[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "double", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_limit_0__; ++i_0__) {
            y[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("cens_x", "N", N);
        context__.validate_dims("data initialization", "cens_x", "int", context__.to_vec(N));
        validate_non_negative_index("cens_x", "N", N);
        cens_x = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_x");
        pos__ = 0;
        size_t cens_x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_x_limit_0__; ++i_0__) {
            cens_x[i_0__] = vals_i__[pos__++];
        }
        validate_non_negative_index("cens_y", "N", N);
        context__.validate_dims("data initialization", "cens_y", "int", context__.to_vec(N));
        validate_non_negative_index("cens_y", "N", N);
        cens_y = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_y");
        pos__ = 0;
        size_t cens_y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_y_limit_0__; ++i_0__) {
            cens_y[i_0__] = vals_i__[pos__++];
        }

        // validate, data variables
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_censored_correlations_unkown_l() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma_x")))
            throw std::runtime_error("variable sigma_x missing");
        vals_r__ = context__.vals_r("sigma_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_x", "double", context__.to_vec());
        // generate_declaration sigma_x
        double sigma_x(0);
        sigma_x = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_x: ") + e.what());
        }

        if (!(context__.contains_r("sigma_y")))
            throw std::runtime_error("variable sigma_y missing");
        vals_r__ = context__.vals_r("sigma_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_y", "double", context__.to_vec());
        // generate_declaration sigma_y
        double sigma_y(0);
        sigma_y = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_y: ") + e.what());
        }

        if (!(context__.contains_r("mu_x")))
            throw std::runtime_error("variable mu_x missing");
        vals_r__ = context__.vals_r("mu_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_x", "double", context__.to_vec());
        // generate_declaration mu_x
        double mu_x(0);
        mu_x = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_x: ") + e.what());
        }

        if (!(context__.contains_r("mu_y")))
            throw std::runtime_error("variable mu_y missing");
        vals_r__ = context__.vals_r("mu_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_y", "double", context__.to_vec());
        // generate_declaration mu_y
        double mu_y(0);
        mu_y = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_y: ") + e.what());
        }

        if (!(context__.contains_r("rho")))
            throw std::runtime_error("variable rho missing");
        vals_r__ = context__.vals_r("rho");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho", "double", context__.to_vec());
        // generate_declaration rho
        double rho(0);
        rho = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho: ") + e.what());
        }

        if (!(context__.contains_r("L_x")))
            throw std::runtime_error("variable L_x missing");
        vals_r__ = context__.vals_r("L_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "L_x", "double", context__.to_vec());
        // generate_declaration L_x
        double L_x(0);
        L_x = vals_r__[pos__++];
        try {
            writer__.scalar_ub_unconstrain(min(x),L_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable L_x: ") + e.what());
        }

        if (!(context__.contains_r("L_y")))
            throw std::runtime_error("variable L_y missing");
        vals_r__ = context__.vals_r("L_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "L_y", "double", context__.to_vec());
        // generate_declaration L_y
        double L_y(0);
        L_y = vals_r__[pos__++];
        try {
            writer__.scalar_ub_unconstrain(min(y),L_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable L_y: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ sigma_x;
        (void) sigma_x;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_x = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_x = in__.scalar_lb_constrain(0);

        T__ sigma_y;
        (void) sigma_y;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_y = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_y = in__.scalar_lb_constrain(0);

        T__ mu_x;
        (void) mu_x;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_x = in__.scalar_constrain(lp__);
        else
            mu_x = in__.scalar_constrain();

        T__ mu_y;
        (void) mu_y;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_y = in__.scalar_constrain(lp__);
        else
            mu_y = in__.scalar_constrain();

        T__ rho;
        (void) rho;  // dummy to suppress unused var warning
        if (jacobian__)
            rho = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho = in__.scalar_lub_constrain(-(1),1);

        T__ L_x;
        (void) L_x;  // dummy to suppress unused var warning
        if (jacobian__)
            L_x = in__.scalar_ub_constrain(min(x),lp__);
        else
            L_x = in__.scalar_ub_constrain(min(x));

        T__ L_y;
        (void) L_y;  // dummy to suppress unused var warning
        if (jacobian__)
            L_y = in__.scalar_ub_constrain(min(y),lp__);
        else
            L_y = in__.scalar_ub_constrain(min(y));


        // transformed parameters
        validate_non_negative_index("mu", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, DUMMY_VAR__);
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, DUMMY_VAR__);
        stan::math::fill(T,DUMMY_VAR__);


        try {
            current_statement_begin__ = 43;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 44;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 45;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 46;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 48;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 49;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        stan::math::check_cov_matrix(function__,"T",T);

        // model body
        try {

            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(mu_x, 0, 1));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(mu_y, 0, 1));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(sigma_x, 1, 1));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(sigma_y, 1, 1));
            current_statement_begin__ = 59;
            lp_accum__.add(normal_log<propto__>(L_x, 0, 5));
            current_statement_begin__ = 60;
            lp_accum__.add(normal_log<propto__>(L_y, 0, 5));
            current_statement_begin__ = 63;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 64;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 65;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(x,i,"x",1)).add(get_base1(y,i,"y",1)).array()),mu,T));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 68;
                    lp_accum__.add((normal_log(get_base1(x,i,"x",1),mu_x,sigma_x) + normal_cdf_log(L_y,(mu_y + ((rho * (sigma_y / sigma_x)) * (get_base1(x,i,"x",1) - mu_x))),(sigma_y * sqrt((1 - square(rho)))))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 71;
                    lp_accum__.add((normal_log(get_base1(y,i,"y",1),mu_y,sigma_y) + normal_cdf_log(L_x,(mu_x + ((rho * (sigma_x / sigma_y)) * (get_base1(y,i,"y",1) - mu_y))),(sigma_x * sqrt((1 - square(rho)))))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 74;
                    lp_accum__.add(log(binormal_cdf(((L_x - mu_x) / sigma_x),((L_y - mu_y) / sigma_y),rho, pstream__)));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma_x");
        names__.push_back("sigma_y");
        names__.push_back("mu_x");
        names__.push_back("mu_y");
        names__.push_back("rho");
        names__.push_back("L_x");
        names__.push_back("L_y");
        names__.push_back("mu");
        names__.push_back("T");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_censored_correlations_unkown_l_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double sigma_x = in__.scalar_lb_constrain(0);
        double sigma_y = in__.scalar_lb_constrain(0);
        double mu_x = in__.scalar_constrain();
        double mu_y = in__.scalar_constrain();
        double rho = in__.scalar_lub_constrain(-(1),1);
        double L_x = in__.scalar_ub_constrain(min(x));
        double L_y = in__.scalar_ub_constrain(min(y));
        vars__.push_back(sigma_x);
        vars__.push_back(sigma_y);
        vars__.push_back(mu_x);
        vars__.push_back(mu_y);
        vars__.push_back(rho);
        vars__.push_back(L_x);
        vars__.push_back(L_y);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        validate_non_negative_index("mu", "2", 2);
        vector_d mu(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu;  // dummy to suppress unused var warning

        stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu,DUMMY_VAR__);
        validate_non_negative_index("T", "2", 2);
        matrix_d T(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T;  // dummy to suppress unused var warning

        stan::math::initialize(T, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T,DUMMY_VAR__);


        try {
            current_statement_begin__ = 43;
            stan::math::assign(get_base1_lhs(T,1,1,"T",1), square(sigma_x));
            current_statement_begin__ = 44;
            stan::math::assign(get_base1_lhs(T,1,2,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 45;
            stan::math::assign(get_base1_lhs(T,2,1,"T",1), ((rho * sigma_x) * sigma_y));
            current_statement_begin__ = 46;
            stan::math::assign(get_base1_lhs(T,2,2,"T",1), square(sigma_y));
            current_statement_begin__ = 48;
            stan::math::assign(get_base1_lhs(mu,1,"mu",1), mu_x);
            current_statement_begin__ = 49;
            stan::math::assign(get_base1_lhs(mu,2,"mu",1), mu_y);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        stan::math::check_cov_matrix(function__,"T",T);

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu[k_0__]);
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T(k_0__, k_1__));
            }
        }

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_censored_correlations_unkown_l";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "L_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "L_y";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "L_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "L_y";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.15.0

#include <stan/model/model_header.hpp>

namespace model_censored_correlations_z_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_cdf(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 6;
        if (as_bool((primitive_value(logical_neq(z1,0)) || primitive_value(logical_neq(z2,0))))) {
            {
                fun_scalar_t__ denom;
                (void) denom;  // dummy to suppress unused var warning

                stan::math::initialize(denom, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(denom,DUMMY_VAR__);
                stan::math::assign(denom,(logical_lt(fabs(rho),1.0) ? sqrt(((1 + rho) * (1 - rho))) : stan::math::not_a_number() ));
                fun_scalar_t__ a1;
                (void) a1;  // dummy to suppress unused var warning

                stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a1,DUMMY_VAR__);
                stan::math::assign(a1,(((z2 / z1) - rho) / denom));
                fun_scalar_t__ a2;
                (void) a2;  // dummy to suppress unused var warning

                stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(a2,DUMMY_VAR__);
                stan::math::assign(a2,(((z1 / z2) - rho) / denom));
                fun_scalar_t__ product;
                (void) product;  // dummy to suppress unused var warning

                stan::math::initialize(product, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(product,DUMMY_VAR__);
                stan::math::assign(product,(z1 * z2));
                fun_scalar_t__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                stan::math::assign(delta,(primitive_value(logical_lt(product,0)) || primitive_value((primitive_value(logical_eq(product,0)) && primitive_value(logical_lt((z1 + z2),0))))));


                current_statement_begin__ = 12;
                return stan::math::promote_scalar<fun_return_scalar_t__>((((0.5 * ((Phi(z1) + Phi(z2)) - delta)) - owens_t(z1,a1)) - owens_t(z2,a2)));
            }
        }
        current_statement_begin__ = 14;
        return stan::math::promote_scalar<fun_return_scalar_t__>((0.25 + (asin(rho) / (2 * stan::math::pi()))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                 const T1__& z2,
                 const T2__& rho, std::ostream* pstream__) const {
        return binormal_cdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
binormal_ccdf(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 18;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binormal_cdf(-(z1),-(z2),rho, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct binormal_ccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& z1,
                  const T1__& z2,
                  const T2__& rho, std::ostream* pstream__) const {
        return binormal_ccdf(z1, z2, rho, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
log_sub_exp(const T0__& a,
                const T1__& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 22;
        return stan::math::promote_scalar<fun_return_scalar_t__>((logical_gt(a,b) ? (a + log((1 - exp((b - a))))) : (b + log((exp((a - b)) - 1))) ));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct log_sub_exp_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& a,
                const T1__& b, std::ostream* pstream__) const {
        return log_sub_exp(a, b, pstream__);
    }
};

class model_censored_correlations_z : public prob_grad {
private:
    int N;
    vector<double> x_lower;
    vector<double> x_upper;
    vector<double> y_lower;
    vector<double> y_upper;
    vector<double> z;
    vector<int> cens_x;
    vector<int> cens_y;
public:
    model_censored_correlations_z(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        ctor_body(context__, base_rng, pstream__);
    }

    template <class RNG>
    model_censored_correlations_z(stan::io::var_context& context__,
        RNG& base_rng__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, base_rng__, pstream__);
    }

    template <class RNG>
    void ctor_body(stan::io::var_context& context__,
                   RNG& base_rng__,
                   std::ostream* pstream__) {
        current_statement_begin__ = -1;

        static const char* function__ = "model_censored_correlations_z_namespace::model_censored_correlations_z";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("x_lower", "N", N);
        context__.validate_dims("data initialization", "x_lower", "double", context__.to_vec(N));
        validate_non_negative_index("x_lower", "N", N);
        x_lower = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x_lower");
        pos__ = 0;
        size_t x_lower_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_lower_limit_0__; ++i_0__) {
            x_lower[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("x_upper", "N", N);
        context__.validate_dims("data initialization", "x_upper", "double", context__.to_vec(N));
        validate_non_negative_index("x_upper", "N", N);
        x_upper = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("x_upper");
        pos__ = 0;
        size_t x_upper_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < x_upper_limit_0__; ++i_0__) {
            x_upper[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y_lower", "N", N);
        context__.validate_dims("data initialization", "y_lower", "double", context__.to_vec(N));
        validate_non_negative_index("y_lower", "N", N);
        y_lower = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y_lower");
        pos__ = 0;
        size_t y_lower_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_lower_limit_0__; ++i_0__) {
            y_lower[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("y_upper", "N", N);
        context__.validate_dims("data initialization", "y_upper", "double", context__.to_vec(N));
        validate_non_negative_index("y_upper", "N", N);
        y_upper = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("y_upper");
        pos__ = 0;
        size_t y_upper_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < y_upper_limit_0__; ++i_0__) {
            y_upper[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("z", "N", N);
        context__.validate_dims("data initialization", "z", "double", context__.to_vec(N));
        validate_non_negative_index("z", "N", N);
        z = std::vector<double>(N,double(0));
        vals_r__ = context__.vals_r("z");
        pos__ = 0;
        size_t z_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < z_limit_0__; ++i_0__) {
            z[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("cens_x", "N", N);
        context__.validate_dims("data initialization", "cens_x", "int", context__.to_vec(N));
        validate_non_negative_index("cens_x", "N", N);
        cens_x = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_x");
        pos__ = 0;
        size_t cens_x_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_x_limit_0__; ++i_0__) {
            cens_x[i_0__] = vals_i__[pos__++];
        }
        validate_non_negative_index("cens_y", "N", N);
        context__.validate_dims("data initialization", "cens_y", "int", context__.to_vec(N));
        validate_non_negative_index("cens_y", "N", N);
        cens_y = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("cens_y");
        pos__ = 0;
        size_t cens_y_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < cens_y_limit_0__; ++i_0__) {
            cens_y[i_0__] = vals_i__[pos__++];
        }

        // validate, data variables
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_censored_correlations_z() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_x")))
            throw std::runtime_error("variable mu_x missing");
        vals_r__ = context__.vals_r("mu_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_x", "double", context__.to_vec());
        // generate_declaration mu_x
        double mu_x(0);
        mu_x = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_x: ") + e.what());
        }

        if (!(context__.contains_r("mu_y")))
            throw std::runtime_error("variable mu_y missing");
        vals_r__ = context__.vals_r("mu_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_y", "double", context__.to_vec());
        // generate_declaration mu_y
        double mu_y(0);
        mu_y = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_y: ") + e.what());
        }

        if (!(context__.contains_r("mu_z")))
            throw std::runtime_error("variable mu_z missing");
        vals_r__ = context__.vals_r("mu_z");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_z", "double", context__.to_vec());
        // generate_declaration mu_z
        double mu_z(0);
        mu_z = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(mu_z);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_z: ") + e.what());
        }

        if (!(context__.contains_r("sigma_x")))
            throw std::runtime_error("variable sigma_x missing");
        vals_r__ = context__.vals_r("sigma_x");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_x", "double", context__.to_vec());
        // generate_declaration sigma_x
        double sigma_x(0);
        sigma_x = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_x);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_x: ") + e.what());
        }

        if (!(context__.contains_r("sigma_y")))
            throw std::runtime_error("variable sigma_y missing");
        vals_r__ = context__.vals_r("sigma_y");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_y", "double", context__.to_vec());
        // generate_declaration sigma_y
        double sigma_y(0);
        sigma_y = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_y);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_y: ") + e.what());
        }

        if (!(context__.contains_r("sigma_z")))
            throw std::runtime_error("variable sigma_z missing");
        vals_r__ = context__.vals_r("sigma_z");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_z", "double", context__.to_vec());
        // generate_declaration sigma_z
        double sigma_z(0);
        sigma_z = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_z);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_z: ") + e.what());
        }

        if (!(context__.contains_r("rho_xy")))
            throw std::runtime_error("variable rho_xy missing");
        vals_r__ = context__.vals_r("rho_xy");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho_xy", "double", context__.to_vec());
        // generate_declaration rho_xy
        double rho_xy(0);
        rho_xy = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho_xy);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_xy: ") + e.what());
        }

        if (!(context__.contains_r("rho_xz")))
            throw std::runtime_error("variable rho_xz missing");
        vals_r__ = context__.vals_r("rho_xz");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho_xz", "double", context__.to_vec());
        // generate_declaration rho_xz
        double rho_xz(0);
        rho_xz = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho_xz);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_xz: ") + e.what());
        }

        if (!(context__.contains_r("rho_yz")))
            throw std::runtime_error("variable rho_yz missing");
        vals_r__ = context__.vals_r("rho_yz");
        pos__ = 0U;
        context__.validate_dims("initialization", "rho_yz", "double", context__.to_vec());
        // generate_declaration rho_yz
        double rho_yz(0);
        rho_yz = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(1),1,rho_yz);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_yz: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ mu_x;
        (void) mu_x;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_x = in__.scalar_constrain(lp__);
        else
            mu_x = in__.scalar_constrain();

        T__ mu_y;
        (void) mu_y;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_y = in__.scalar_constrain(lp__);
        else
            mu_y = in__.scalar_constrain();

        T__ mu_z;
        (void) mu_z;  // dummy to suppress unused var warning
        if (jacobian__)
            mu_z = in__.scalar_constrain(lp__);
        else
            mu_z = in__.scalar_constrain();

        T__ sigma_x;
        (void) sigma_x;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_x = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_x = in__.scalar_lb_constrain(0);

        T__ sigma_y;
        (void) sigma_y;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_y = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_y = in__.scalar_lb_constrain(0);

        T__ sigma_z;
        (void) sigma_z;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_z = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_z = in__.scalar_lb_constrain(0);

        T__ rho_xy;
        (void) rho_xy;  // dummy to suppress unused var warning
        if (jacobian__)
            rho_xy = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho_xy = in__.scalar_lub_constrain(-(1),1);

        T__ rho_xz;
        (void) rho_xz;  // dummy to suppress unused var warning
        if (jacobian__)
            rho_xz = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho_xz = in__.scalar_lub_constrain(-(1),1);

        T__ rho_yz;
        (void) rho_yz;  // dummy to suppress unused var warning
        if (jacobian__)
            rho_yz = in__.scalar_lub_constrain(-(1),1,lp__);
        else
            rho_yz = in__.scalar_lub_constrain(-(1),1);


        // transformed parameters
        validate_non_negative_index("mu_xy", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_xy(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_xy;  // dummy to suppress unused var warning

        stan::math::initialize(mu_xy, DUMMY_VAR__);
        stan::math::fill(mu_xy,DUMMY_VAR__);
        validate_non_negative_index("mu_xz", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_xz(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_xz;  // dummy to suppress unused var warning

        stan::math::initialize(mu_xz, DUMMY_VAR__);
        stan::math::fill(mu_xz,DUMMY_VAR__);
        validate_non_negative_index("mu_yz", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_yz(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_yz;  // dummy to suppress unused var warning

        stan::math::initialize(mu_yz, DUMMY_VAR__);
        stan::math::fill(mu_yz,DUMMY_VAR__);
        validate_non_negative_index("T_xy", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T_xy(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_xy;  // dummy to suppress unused var warning

        stan::math::initialize(T_xy, DUMMY_VAR__);
        stan::math::fill(T_xy,DUMMY_VAR__);
        validate_non_negative_index("T_xz", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T_xz(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_xz;  // dummy to suppress unused var warning

        stan::math::initialize(T_xz, DUMMY_VAR__);
        stan::math::fill(T_xz,DUMMY_VAR__);
        validate_non_negative_index("T_yz", "2", 2);
        Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T_yz(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_yz;  // dummy to suppress unused var warning

        stan::math::initialize(T_yz, DUMMY_VAR__);
        stan::math::fill(T_yz,DUMMY_VAR__);
        T__ sigma_x_adj;
        (void) sigma_x_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_x_adj, DUMMY_VAR__);
        stan::math::fill(sigma_x_adj,DUMMY_VAR__);
        T__ sigma_y_adj;
        (void) sigma_y_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_y_adj, DUMMY_VAR__);
        stan::math::fill(sigma_y_adj,DUMMY_VAR__);
        T__ rho_xy_coef;
        (void) rho_xy_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_xy_coef, DUMMY_VAR__);
        stan::math::fill(rho_xy_coef,DUMMY_VAR__);
        T__ rho_yx_coef;
        (void) rho_yx_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_yx_coef, DUMMY_VAR__);
        stan::math::fill(rho_yx_coef,DUMMY_VAR__);


        try {
            current_statement_begin__ = 60;
            stan::math::assign(get_base1_lhs(T_xy,1,1,"T_xy",1), square(sigma_x));
            current_statement_begin__ = 61;
            stan::math::assign(get_base1_lhs(T_xy,1,2,"T_xy",1), ((rho_xy * sigma_x) * sigma_y));
            current_statement_begin__ = 62;
            stan::math::assign(get_base1_lhs(T_xy,2,1,"T_xy",1), ((rho_xy * sigma_x) * sigma_y));
            current_statement_begin__ = 63;
            stan::math::assign(get_base1_lhs(T_xy,2,2,"T_xy",1), square(sigma_y));
            current_statement_begin__ = 65;
            stan::math::assign(get_base1_lhs(T_xz,1,1,"T_xz",1), square(sigma_x));
            current_statement_begin__ = 66;
            stan::math::assign(get_base1_lhs(T_xz,1,2,"T_xz",1), ((rho_xz * sigma_x) * sigma_z));
            current_statement_begin__ = 67;
            stan::math::assign(get_base1_lhs(T_xz,2,1,"T_xz",1), ((rho_xz * sigma_x) * sigma_z));
            current_statement_begin__ = 68;
            stan::math::assign(get_base1_lhs(T_xz,2,2,"T_xz",1), square(sigma_z));
            current_statement_begin__ = 70;
            stan::math::assign(get_base1_lhs(T_yz,1,1,"T_yz",1), square(sigma_y));
            current_statement_begin__ = 71;
            stan::math::assign(get_base1_lhs(T_yz,1,2,"T_yz",1), ((rho_yz * sigma_y) * sigma_z));
            current_statement_begin__ = 72;
            stan::math::assign(get_base1_lhs(T_yz,2,1,"T_yz",1), ((rho_yz * sigma_y) * sigma_z));
            current_statement_begin__ = 73;
            stan::math::assign(get_base1_lhs(T_yz,2,2,"T_yz",1), square(sigma_z));
            current_statement_begin__ = 75;
            stan::math::assign(get_base1_lhs(mu_xy,1,"mu_xy",1), mu_x);
            current_statement_begin__ = 76;
            stan::math::assign(get_base1_lhs(mu_xy,2,"mu_xy",1), mu_y);
            current_statement_begin__ = 78;
            stan::math::assign(get_base1_lhs(mu_xz,1,"mu_xz",1), mu_x);
            current_statement_begin__ = 79;
            stan::math::assign(get_base1_lhs(mu_xz,2,"mu_xz",1), mu_z);
            current_statement_begin__ = 81;
            stan::math::assign(get_base1_lhs(mu_yz,1,"mu_yz",1), mu_y);
            current_statement_begin__ = 82;
            stan::math::assign(get_base1_lhs(mu_yz,2,"mu_yz",1), mu_z);
            current_statement_begin__ = 84;
            stan::math::assign(sigma_x_adj, (sigma_x * sqrt((1 - square(rho_xy)))));
            current_statement_begin__ = 85;
            stan::math::assign(sigma_y_adj, (sigma_y * sqrt((1 - square(rho_xy)))));
            current_statement_begin__ = 87;
            stan::math::assign(rho_xy_coef, (rho_xy * (sigma_x / sigma_y)));
            current_statement_begin__ = 88;
            stan::math::assign(rho_yx_coef, (rho_xy * (sigma_y / sigma_x)));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu_xy(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu_xy" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu_xz(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu_xz" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(mu_yz(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: mu_yz" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T_xy(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T_xy" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T_xz(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T_xz" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            for (int i1__ = 0; i1__ < 2; ++i1__) {
                if (stan::math::is_uninitialized(T_yz(i0__,i1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: T_yz" << '[' << i0__ << ']' << '[' << i1__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
        }
        if (stan::math::is_uninitialized(sigma_x_adj)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sigma_x_adj";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(sigma_y_adj)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sigma_y_adj";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(rho_xy_coef)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: rho_xy_coef";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(rho_yx_coef)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: rho_yx_coef";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        stan::math::check_cov_matrix(function__,"T_xy",T_xy);
        stan::math::check_cov_matrix(function__,"T_xz",T_xz);
        stan::math::check_cov_matrix(function__,"T_yz",T_yz);

        // model body
        try {

            current_statement_begin__ = 91;
            lp_accum__.add(normal_log<propto__>(mu_x, 0, 1));
            current_statement_begin__ = 92;
            lp_accum__.add(normal_log<propto__>(mu_y, 0, 1));
            current_statement_begin__ = 93;
            lp_accum__.add(normal_log<propto__>(mu_z, 0, 1));
            current_statement_begin__ = 95;
            lp_accum__.add(normal_log<propto__>(sigma_x, 1, 1));
            current_statement_begin__ = 96;
            lp_accum__.add(normal_log<propto__>(sigma_y, 1, 1));
            current_statement_begin__ = 97;
            lp_accum__.add(normal_log<propto__>(sigma_z, 1, 1));
            current_statement_begin__ = 99;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 105;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 106;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(x_lower,i,"x_lower",1)).add(get_base1(y_lower,i,"y_lower",1)).array()),mu_xy,T_xy));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_neq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 111;
                    lp_accum__.add(normal_log(get_base1(x_lower,i,"x_lower",1),mu_x,sigma_x));
                    current_statement_begin__ = 113;
                    if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))) {

                        current_statement_begin__ = 114;
                        lp_accum__.add(normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),1))) {

                        current_statement_begin__ = 117;
                        lp_accum__.add(normal_ccdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),2))) {

                        current_statement_begin__ = 120;
                        lp_accum__.add(log_sub_exp(normal_cdf_log(get_base1(y_upper,i,"y_upper",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj),normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + (rho_yx_coef * (get_base1(x_lower,i,"x_lower",1) - mu_x))),sigma_y_adj), pstream__));
                    }
                } else if (as_bool((primitive_value(logical_neq(get_base1(cens_x,i,"cens_x",1),0)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),0))))) {

                    current_statement_begin__ = 129;
                    lp_accum__.add(normal_log(get_base1(y_lower,i,"y_lower",1),mu_y,sigma_y));
                    current_statement_begin__ = 131;
                    if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1)))) {

                        current_statement_begin__ = 132;
                        lp_accum__.add(normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),1))) {

                        current_statement_begin__ = 135;
                        lp_accum__.add(normal_ccdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj));
                    } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),2))) {

                        current_statement_begin__ = 138;
                        lp_accum__.add(log_sub_exp(normal_cdf_log(get_base1(x_upper,i,"x_upper",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj),normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + (rho_xy_coef * (get_base1(y_lower,i,"y_lower",1) - mu_y))),sigma_x_adj), pstream__));
                    }
                }
                current_statement_begin__ = 146;
                if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 147;
                    lp_accum__.add(log(binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 152;
                    lp_accum__.add(log(binormal_ccdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 156;
                    lp_accum__.add(log(binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),-(rho_xy), pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 161;
                    lp_accum__.add(log(binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),-(rho_xy), pstream__)));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1))) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 165;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho_xy, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),1)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 170;
                    lp_accum__.add(log((binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho_xy, pstream__) - binormal_cdf(((-(get_base1(x_lower,i,"x_lower",1)) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))))) {

                    current_statement_begin__ = 174;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),1))))) {

                    current_statement_begin__ = 179;
                    lp_accum__.add(log((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),rho_xy, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((-(get_base1(y_lower,i,"y_lower",1)) - mu_y) / sigma_y),rho_xy, pstream__))));
                } else if (as_bool((primitive_value(logical_eq(get_base1(cens_x,i,"cens_x",1),2)) && primitive_value(logical_eq(get_base1(cens_y,i,"cens_y",1),2))))) {

                    current_statement_begin__ = 183;
                    lp_accum__.add(log((((binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho_xy, pstream__) - binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_upper,i,"y_upper",1) - mu_y) / sigma_y),rho_xy, pstream__)) - binormal_cdf(((get_base1(x_upper,i,"x_upper",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__)) + binormal_cdf(((get_base1(x_lower,i,"x_lower",1) - mu_x) / sigma_x),((get_base1(y_lower,i,"y_lower",1) - mu_y) / sigma_y),rho_xy, pstream__))));
                }
                current_statement_begin__ = 204;
                if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),0))) {

                    current_statement_begin__ = 205;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(x_lower,i,"x_lower",1)).add(get_base1(z,i,"z",1)).array()),mu_xz,T_xz));
                } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),-(1)))) {

                    current_statement_begin__ = 209;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz)))))));
                } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),1))) {

                    current_statement_begin__ = 213;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + normal_ccdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz)))))));
                } else if (as_bool(logical_eq(get_base1(cens_x,i,"cens_x",1),2))) {

                    current_statement_begin__ = 217;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + log_sub_exp(normal_cdf_log(get_base1(x_upper,i,"x_upper",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz))))),normal_cdf_log(get_base1(x_lower,i,"x_lower",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz))))), pstream__)));
                }
                current_statement_begin__ = 228;
                if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),0))) {

                    current_statement_begin__ = 229;
                    lp_accum__.add(multi_normal_log(stan::math::to_row_vector(stan::math::array_builder<double >().add(get_base1(y_lower,i,"y_lower",1)).add(get_base1(z,i,"z",1)).array()),mu_yz,T_yz));
                } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),-(1)))) {

                    current_statement_begin__ = 233;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + ((rho_yz * (sigma_y / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_y * sqrt((1 - square(rho_yz)))))));
                } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),1))) {

                    current_statement_begin__ = 237;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + normal_ccdf_log(get_base1(y_lower,i,"y_lower",1),(mu_y + ((rho_yz * (sigma_y / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_y * sqrt((1 - square(rho_yz)))))));
                } else if (as_bool(logical_eq(get_base1(cens_y,i,"cens_y",1),2))) {

                    current_statement_begin__ = 241;
                    lp_accum__.add((normal_log(get_base1(z,i,"z",1),mu_z,sigma_z) + log_sub_exp(normal_cdf_log(get_base1(y_upper,i,"y_upper",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz))))),normal_cdf_log(get_base1(y_lower,i,"y_lower",1),(mu_x + ((rho_xz * (sigma_x / sigma_z)) * (get_base1(z,i,"z",1) - mu_z))),(sigma_x * sqrt((1 - square(rho_xz))))), pstream__)));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_x");
        names__.push_back("mu_y");
        names__.push_back("mu_z");
        names__.push_back("sigma_x");
        names__.push_back("sigma_y");
        names__.push_back("sigma_z");
        names__.push_back("rho_xy");
        names__.push_back("rho_xz");
        names__.push_back("rho_yz");
        names__.push_back("mu_xy");
        names__.push_back("mu_xz");
        names__.push_back("mu_yz");
        names__.push_back("T_xy");
        names__.push_back("T_xz");
        names__.push_back("T_yz");
        names__.push_back("sigma_x_adj");
        names__.push_back("sigma_y_adj");
        names__.push_back("rho_xy_coef");
        names__.push_back("rho_yx_coef");
        names__.push_back("sigma_xy");
        names__.push_back("sigma_xz");
        names__.push_back("sigma_yz");
        names__.push_back("cor_xy");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_censored_correlations_z_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double mu_x = in__.scalar_constrain();
        double mu_y = in__.scalar_constrain();
        double mu_z = in__.scalar_constrain();
        double sigma_x = in__.scalar_lb_constrain(0);
        double sigma_y = in__.scalar_lb_constrain(0);
        double sigma_z = in__.scalar_lb_constrain(0);
        double rho_xy = in__.scalar_lub_constrain(-(1),1);
        double rho_xz = in__.scalar_lub_constrain(-(1),1);
        double rho_yz = in__.scalar_lub_constrain(-(1),1);
        vars__.push_back(mu_x);
        vars__.push_back(mu_y);
        vars__.push_back(mu_z);
        vars__.push_back(sigma_x);
        vars__.push_back(sigma_y);
        vars__.push_back(sigma_z);
        vars__.push_back(rho_xy);
        vars__.push_back(rho_xz);
        vars__.push_back(rho_yz);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        validate_non_negative_index("mu_xy", "2", 2);
        vector_d mu_xy(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_xy;  // dummy to suppress unused var warning

        stan::math::initialize(mu_xy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu_xy,DUMMY_VAR__);
        validate_non_negative_index("mu_xz", "2", 2);
        vector_d mu_xz(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_xz;  // dummy to suppress unused var warning

        stan::math::initialize(mu_xz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu_xz,DUMMY_VAR__);
        validate_non_negative_index("mu_yz", "2", 2);
        vector_d mu_yz(static_cast<Eigen::VectorXd::Index>(2));
        (void) mu_yz;  // dummy to suppress unused var warning

        stan::math::initialize(mu_yz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(mu_yz,DUMMY_VAR__);
        validate_non_negative_index("T_xy", "2", 2);
        matrix_d T_xy(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_xy;  // dummy to suppress unused var warning

        stan::math::initialize(T_xy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T_xy,DUMMY_VAR__);
        validate_non_negative_index("T_xz", "2", 2);
        matrix_d T_xz(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_xz;  // dummy to suppress unused var warning

        stan::math::initialize(T_xz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T_xz,DUMMY_VAR__);
        validate_non_negative_index("T_yz", "2", 2);
        matrix_d T_yz(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) T_yz;  // dummy to suppress unused var warning

        stan::math::initialize(T_yz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(T_yz,DUMMY_VAR__);
        double sigma_x_adj(0.0);
        (void) sigma_x_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_x_adj, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_x_adj,DUMMY_VAR__);
        double sigma_y_adj(0.0);
        (void) sigma_y_adj;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_y_adj, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_y_adj,DUMMY_VAR__);
        double rho_xy_coef(0.0);
        (void) rho_xy_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_xy_coef, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rho_xy_coef,DUMMY_VAR__);
        double rho_yx_coef(0.0);
        (void) rho_yx_coef;  // dummy to suppress unused var warning

        stan::math::initialize(rho_yx_coef, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rho_yx_coef,DUMMY_VAR__);


        try {
            current_statement_begin__ = 60;
            stan::math::assign(get_base1_lhs(T_xy,1,1,"T_xy",1), square(sigma_x));
            current_statement_begin__ = 61;
            stan::math::assign(get_base1_lhs(T_xy,1,2,"T_xy",1), ((rho_xy * sigma_x) * sigma_y));
            current_statement_begin__ = 62;
            stan::math::assign(get_base1_lhs(T_xy,2,1,"T_xy",1), ((rho_xy * sigma_x) * sigma_y));
            current_statement_begin__ = 63;
            stan::math::assign(get_base1_lhs(T_xy,2,2,"T_xy",1), square(sigma_y));
            current_statement_begin__ = 65;
            stan::math::assign(get_base1_lhs(T_xz,1,1,"T_xz",1), square(sigma_x));
            current_statement_begin__ = 66;
            stan::math::assign(get_base1_lhs(T_xz,1,2,"T_xz",1), ((rho_xz * sigma_x) * sigma_z));
            current_statement_begin__ = 67;
            stan::math::assign(get_base1_lhs(T_xz,2,1,"T_xz",1), ((rho_xz * sigma_x) * sigma_z));
            current_statement_begin__ = 68;
            stan::math::assign(get_base1_lhs(T_xz,2,2,"T_xz",1), square(sigma_z));
            current_statement_begin__ = 70;
            stan::math::assign(get_base1_lhs(T_yz,1,1,"T_yz",1), square(sigma_y));
            current_statement_begin__ = 71;
            stan::math::assign(get_base1_lhs(T_yz,1,2,"T_yz",1), ((rho_yz * sigma_y) * sigma_z));
            current_statement_begin__ = 72;
            stan::math::assign(get_base1_lhs(T_yz,2,1,"T_yz",1), ((rho_yz * sigma_y) * sigma_z));
            current_statement_begin__ = 73;
            stan::math::assign(get_base1_lhs(T_yz,2,2,"T_yz",1), square(sigma_z));
            current_statement_begin__ = 75;
            stan::math::assign(get_base1_lhs(mu_xy,1,"mu_xy",1), mu_x);
            current_statement_begin__ = 76;
            stan::math::assign(get_base1_lhs(mu_xy,2,"mu_xy",1), mu_y);
            current_statement_begin__ = 78;
            stan::math::assign(get_base1_lhs(mu_xz,1,"mu_xz",1), mu_x);
            current_statement_begin__ = 79;
            stan::math::assign(get_base1_lhs(mu_xz,2,"mu_xz",1), mu_z);
            current_statement_begin__ = 81;
            stan::math::assign(get_base1_lhs(mu_yz,1,"mu_yz",1), mu_y);
            current_statement_begin__ = 82;
            stan::math::assign(get_base1_lhs(mu_yz,2,"mu_yz",1), mu_z);
            current_statement_begin__ = 84;
            stan::math::assign(sigma_x_adj, (sigma_x * sqrt((1 - square(rho_xy)))));
            current_statement_begin__ = 85;
            stan::math::assign(sigma_y_adj, (sigma_y * sqrt((1 - square(rho_xy)))));
            current_statement_begin__ = 87;
            stan::math::assign(rho_xy_coef, (rho_xy * (sigma_x / sigma_y)));
            current_statement_begin__ = 88;
            stan::math::assign(rho_yx_coef, (rho_xy * (sigma_y / sigma_x)));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        stan::math::check_cov_matrix(function__,"T_xy",T_xy);
        stan::math::check_cov_matrix(function__,"T_xz",T_xz);
        stan::math::check_cov_matrix(function__,"T_yz",T_yz);

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_xy[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_xz[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_yz[k_0__]);
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T_xy(k_0__, k_1__));
            }
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T_xz(k_0__, k_1__));
            }
        }
        for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
                vars__.push_back(T_yz(k_0__, k_1__));
            }
        }
        vars__.push_back(sigma_x_adj);
        vars__.push_back(sigma_y_adj);
        vars__.push_back(rho_xy_coef);
        vars__.push_back(rho_yx_coef);

        if (!include_gqs__) return;
        // declare and define generated quantities
        double sigma_xy(0.0);
        (void) sigma_xy;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_xy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_xy,DUMMY_VAR__);
        stan::math::assign(sigma_xy,get_base1(T_xy,1,2,"T_xy",1));
        double sigma_xz(0.0);
        (void) sigma_xz;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_xz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_xz,DUMMY_VAR__);
        stan::math::assign(sigma_xz,get_base1(T_xz,1,2,"T_xz",1));
        double sigma_yz(0.0);
        (void) sigma_yz;  // dummy to suppress unused var warning

        stan::math::initialize(sigma_yz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sigma_yz,DUMMY_VAR__);
        stan::math::assign(sigma_yz,get_base1(T_yz,1,2,"T_yz",1));
        double cor_xy(0.0);
        (void) cor_xy;  // dummy to suppress unused var warning

        stan::math::initialize(cor_xy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cor_xy,DUMMY_VAR__);
        stan::math::assign(cor_xy,((((sigma_xy - sigma_xz) - sigma_yz) + pow(sigma_z,2)) / sqrt((((pow(sigma_x,2) + pow(sigma_z,2)) - (2 * sigma_xz)) * ((pow(sigma_y,2) + pow(sigma_z,2)) - (2 * sigma_yz))))));


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
        vars__.push_back(sigma_xy);
        vars__.push_back(sigma_xz);
        vars__.push_back(sigma_yz);
        vars__.push_back(cor_xy);

    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_censored_correlations_z";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_z";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_z";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yz";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_xy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_xz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_yz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T_xy" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T_xz" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T_yz" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy_coef";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yx_coef";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_xy";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_xz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_yz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "cor_xy";
        param_names__.push_back(param_name_stream__.str());
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_z";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_z";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yz";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_xy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_xz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_yz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T_xy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T_xz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (2 + ((2 * (2 - 1)) / 2)); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "T_yz" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_x_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_y_adj";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_xy_coef";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "rho_yx_coef";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_xy";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_xz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_yz";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "cor_xy";
        param_names__.push_back(param_name_stream__.str());
    }

}; // model

}




#endif
